{"ast":null,"code":"import * as bcu from 'bigint-crypto-utils';\n/**\n * Class for a Paillier public key\n */\n\nclass PublicKey {\n  /**\n     * Creates an instance of class PublicKey\n     * @param n - The public modulo\n     * @param g - The public generator\n     */\n  constructor(n, g) {\n    this.n = n;\n    this._n2 = this.n ** 2n; // cache n^2\n\n    this.g = g;\n  }\n  /**\n     * Get the bit length of the public modulo\n     * @returns The bit length of the public modulo\n     */\n\n\n  get bitLength() {\n    return bcu.bitLength(this.n);\n  }\n  /**\n     * Paillier public-key encryption\n     *\n     * @param m - A bigint representation of a plaintext message\n     * @param r - The random integer factor for encryption. By default is a random in (1,n)\n     *\n     * @returns The encryption of m with this public key\n     */\n\n\n  encrypt(m, r) {\n    if (r === undefined) {\n      do {\n        r = bcu.randBetween(this.n);\n      } while (bcu.gcd(r, this.n) !== 1n);\n    }\n\n    return bcu.modPow(this.g, m, this._n2) * bcu.modPow(r, this.n, this._n2) % this._n2;\n  }\n  /**\n     * Homomorphic addition\n     *\n     * @param ciphertexts - n >= 2 ciphertexts (c_1,..., c_n) that are the encryption of (m_1, ..., m_n) with this public key\n     *\n     * @returns The encryption of (m_1 + ... + m_2) with this public key\n     */\n\n\n  addition(...ciphertexts) {\n    return ciphertexts.reduce((sum, next) => sum * next % this._n2, 1n);\n  }\n  /**\n     * Pseudo-homomorphic Paillier multiplication\n     *\n     * @param {bigint} c - a number m encrypted with this public key\n     * @param {bigint | number} k - either a bigint or a number\n     *\n     * @returns {bigint} - the encryption of k·m with this public key\n     */\n\n\n  multiply(c, k) {\n    return bcu.modPow(c, k, this._n2);\n  }\n\n}\n/**\n * Class for Paillier private keys.\n */\n\n\nclass PrivateKey {\n  /**\n     * Creates an instance of class PrivateKey\n     *\n     * @param lambda\n     * @param mu\n     * @param publicKey\n     * @param p - a big prime\n     * @param q- a big prime\n     */\n  constructor(lambda, mu, publicKey, p, q) {\n    this.lambda = lambda;\n    this.mu = mu;\n    this._p = p;\n    this._q = q;\n    this.publicKey = publicKey;\n  }\n  /**\n   * Get the bit length of the public modulo\n   * @returns The bit length of the public modulo\n   */\n\n\n  get bitLength() {\n    return bcu.bitLength(this.publicKey.n);\n  }\n  /**\n   * Get the public modulo n=p·q\n   * @returns The public modulo n=p·q\n   */\n\n\n  get n() {\n    return this.publicKey.n;\n  }\n  /**\n   * Paillier private-key decryption\n   *\n   * @param c - A bigint encrypted with the public key\n   *\n   * @returns The decryption of c with this private key\n   */\n\n\n  decrypt(c) {\n    return L(bcu.modPow(c, this.lambda, this.publicKey._n2), this.publicKey.n) * this.mu % this.publicKey.n;\n  }\n  /**\n   * Recover the random factor used for encrypting a message with the complementary public key.\n   * The recovery function only works if the public key generator g was using the simple variant\n   * g = 1 + n\n   * It is also necessary to know p and q (usually stored in the private key)\n   *\n   * @param c - The encryption using the public of message m with random factor r\n   *\n   * @returns The random factor (mod n)\n   *\n   * @throws {RangeError}\n   * Cannot recover the random factor if publicKey.g != publicKey.n + 1. You should generate yout keys using the simple variant, e.g. generateRandomKeys(3072, true) )\n   *\n   * @throws {Error}\n   * Cannot get random factor without knowing p and q\n   *\n   */\n\n\n  getRandomFactor(c) {\n    if (this.publicKey.g !== this.n + 1n) throw RangeError('Cannot recover the random factor if publicKey.g != publicKey.n + 1. You should generate yout keys using the simple variant, e.g. generateRandomKeys(3072, true) )');\n\n    if (this._p === undefined || this._q === undefined) {\n      throw Error('Cannot get random factor without knowing p and q');\n    }\n\n    const m = this.decrypt(c);\n    const phi = (this._p - 1n) * (this._q - 1n);\n    const nInvModPhi = bcu.modInv(this.n, phi);\n    const c1 = c * (1n - m * this.n) % this.publicKey._n2;\n    return bcu.modPow(c1, nInvModPhi, this.n);\n  }\n\n}\n\nfunction L(a, n) {\n  return (a - 1n) / n;\n}\n/**\n * Generates a pair private, public key for the Paillier cryptosystem.\n *\n * @param bitlength - The bit length of the public modulo\n * @param simplevariant - Use the simple variant to compute the generator (g=n+1). This is REQUIRED if you want to be able to recover the random integer factor used when encrypting with the public key\n *\n * @returns A promise that resolves to a {@link KeyPair} of public, private keys\n */\n\n\nasync function generateRandomKeys(bitlength = 3072, simpleVariant = false) {\n  let p, q, n, g, lambda, mu; // if p and q are bitLength/2 long ->  2**(bitLength - 2) <= n < 2**(bitLength)\n\n  do {\n    p = await bcu.prime(Math.floor(bitlength / 2) + 1);\n    q = await bcu.prime(Math.floor(bitlength / 2));\n    n = p * q;\n  } while (q === p || bcu.bitLength(n) !== bitlength);\n\n  if (simpleVariant) {\n    // If using p,q of equivalent length, a simpler variant of the key\n    // generation steps would be to set\n    // g=n+1, lambda=(p-1)(q-1), mu=lambda.invertm(n)\n    g = n + 1n;\n    lambda = (p - 1n) * (q - 1n);\n    mu = bcu.modInv(lambda, n);\n  } else {\n    const n2 = n ** 2n;\n    g = getGenerator(n, n2);\n    lambda = bcu.lcm(p - 1n, q - 1n);\n    mu = bcu.modInv(L(bcu.modPow(g, lambda, n2), n), n);\n  }\n\n  const publicKey = new PublicKey(n, g);\n  const privateKey = new PrivateKey(lambda, mu, publicKey, p, q);\n  return {\n    publicKey,\n    privateKey\n  };\n}\n/**\n * Generates a pair private, public key for the Paillier cryptosystem in synchronous mode.\n * Synchronous mode is NOT RECOMMENDED since it won't use workers and thus it'll be slower and may freeze thw window in browser's javascript.\n *\n * @param bitlength - The bit length of the public modulo\n * @param simplevariant - Use the simple variant to compute the generator (g=n+1)\n *\n * @returns A pair of public, private keys\n */\n\n\nfunction generateRandomKeysSync(bitlength = 3072, simpleVariant = false) {\n  let p, q, n, g, lambda, mu; // if p and q are bitLength/2 long ->  2**(bitLength - 2) <= n < 2**(bitLength)\n\n  do {\n    p = bcu.primeSync(Math.floor(bitlength / 2) + 1);\n    q = bcu.primeSync(Math.floor(bitlength / 2));\n    n = p * q;\n  } while (q === p || bcu.bitLength(n) !== bitlength);\n\n  if (simpleVariant) {\n    // If using p,q of equivalent length, a simpler variant of the key\n    // generation steps would be to set\n    // g=n+1, lambda=(p-1)(q-1), mu=lambda.invertm(n)\n    g = n + 1n;\n    lambda = (p - 1n) * (q - 1n);\n    mu = bcu.modInv(lambda, n);\n  } else {\n    const n2 = n ** 2n;\n    g = getGenerator(n, n2);\n    lambda = bcu.lcm(p - 1n, q - 1n);\n    mu = bcu.modInv(L(bcu.modPow(g, lambda, n2), n), n);\n  }\n\n  const publicKey = new PublicKey(n, g);\n  const privateKey = new PrivateKey(lambda, mu, publicKey, p, q);\n  return {\n    publicKey,\n    privateKey\n  };\n}\n\nfunction getGenerator(n, n2) {\n  const alpha = bcu.randBetween(n);\n  const beta = bcu.randBetween(n);\n  return (alpha * n + 1n) * bcu.modPow(beta, n, n2) % n2;\n}\n\nexport { PrivateKey, PublicKey, generateRandomKeys, generateRandomKeysSync };","map":{"version":3,"sources":["../../src/ts/PublicKey.ts","../../src/ts/PrivateKey.ts","../../src/ts/generateRandomKeys.ts"],"names":[],"mappings":"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","sourcesContent":["import * as bcu from 'bigint-crypto-utils';\n\n/**\n * Class for a Paillier public key\n */\nclass PublicKey {\n    /**\n       * Creates an instance of class PublicKey\n       * @param n - The public modulo\n       * @param g - The public generator\n       */\n    constructor(n, g) {\n        this.n = n;\n        this._n2 = this.n ** 2n; // cache n^2\n        this.g = g;\n    }\n    /**\n       * Get the bit length of the public modulo\n       * @returns The bit length of the public modulo\n       */\n    get bitLength() {\n        return bcu.bitLength(this.n);\n    }\n    /**\n       * Paillier public-key encryption\n       *\n       * @param m - A bigint representation of a plaintext message\n       * @param r - The random integer factor for encryption. By default is a random in (1,n)\n       *\n       * @returns The encryption of m with this public key\n       */\n    encrypt(m, r) {\n        if (r === undefined) {\n            do {\n                r = bcu.randBetween(this.n);\n            } while (bcu.gcd(r, this.n) !== 1n);\n        }\n        return (bcu.modPow(this.g, m, this._n2) * bcu.modPow(r, this.n, this._n2)) % this._n2;\n    }\n    /**\n       * Homomorphic addition\n       *\n       * @param ciphertexts - n >= 2 ciphertexts (c_1,..., c_n) that are the encryption of (m_1, ..., m_n) with this public key\n       *\n       * @returns The encryption of (m_1 + ... + m_2) with this public key\n       */\n    addition(...ciphertexts) {\n        return ciphertexts.reduce((sum, next) => sum * next % (this._n2), 1n);\n    }\n    /**\n       * Pseudo-homomorphic Paillier multiplication\n       *\n       * @param {bigint} c - a number m encrypted with this public key\n       * @param {bigint | number} k - either a bigint or a number\n       *\n       * @returns {bigint} - the encryption of k·m with this public key\n       */\n    multiply(c, k) {\n        return bcu.modPow(c, k, this._n2);\n    }\n}\n\n/**\n * Class for Paillier private keys.\n */\nclass PrivateKey {\n    /**\n       * Creates an instance of class PrivateKey\n       *\n       * @param lambda\n       * @param mu\n       * @param publicKey\n       * @param p - a big prime\n       * @param q- a big prime\n       */\n    constructor(lambda, mu, publicKey, p, q) {\n        this.lambda = lambda;\n        this.mu = mu;\n        this._p = p;\n        this._q = q;\n        this.publicKey = publicKey;\n    }\n    /**\n     * Get the bit length of the public modulo\n     * @returns The bit length of the public modulo\n     */\n    get bitLength() {\n        return bcu.bitLength(this.publicKey.n);\n    }\n    /**\n     * Get the public modulo n=p·q\n     * @returns The public modulo n=p·q\n     */\n    get n() {\n        return this.publicKey.n;\n    }\n    /**\n     * Paillier private-key decryption\n     *\n     * @param c - A bigint encrypted with the public key\n     *\n     * @returns The decryption of c with this private key\n     */\n    decrypt(c) {\n        return (L(bcu.modPow(c, this.lambda, this.publicKey._n2), this.publicKey.n) * this.mu) % this.publicKey.n;\n    }\n    /**\n     * Recover the random factor used for encrypting a message with the complementary public key.\n     * The recovery function only works if the public key generator g was using the simple variant\n     * g = 1 + n\n     * It is also necessary to know p and q (usually stored in the private key)\n     *\n     * @param c - The encryption using the public of message m with random factor r\n     *\n     * @returns The random factor (mod n)\n     *\n     * @throws {RangeError}\n     * Cannot recover the random factor if publicKey.g != publicKey.n + 1. You should generate yout keys using the simple variant, e.g. generateRandomKeys(3072, true) )\n     *\n     * @throws {Error}\n     * Cannot get random factor without knowing p and q\n     *\n     */\n    getRandomFactor(c) {\n        if (this.publicKey.g !== this.n + 1n)\n            throw RangeError('Cannot recover the random factor if publicKey.g != publicKey.n + 1. You should generate yout keys using the simple variant, e.g. generateRandomKeys(3072, true) )');\n        if (this._p === undefined || this._q === undefined) {\n            throw Error('Cannot get random factor without knowing p and q');\n        }\n        const m = this.decrypt(c);\n        const phi = (this._p - 1n) * (this._q - 1n);\n        const nInvModPhi = bcu.modInv(this.n, phi);\n        const c1 = c * (1n - m * this.n) % this.publicKey._n2;\n        return bcu.modPow(c1, nInvModPhi, this.n);\n    }\n}\nfunction L(a, n) {\n    return (a - 1n) / n;\n}\n\n/**\n * Generates a pair private, public key for the Paillier cryptosystem.\n *\n * @param bitlength - The bit length of the public modulo\n * @param simplevariant - Use the simple variant to compute the generator (g=n+1). This is REQUIRED if you want to be able to recover the random integer factor used when encrypting with the public key\n *\n * @returns A promise that resolves to a {@link KeyPair} of public, private keys\n */\nasync function generateRandomKeys(bitlength = 3072, simpleVariant = false) {\n    let p, q, n, g, lambda, mu;\n    // if p and q are bitLength/2 long ->  2**(bitLength - 2) <= n < 2**(bitLength)\n    do {\n        p = await bcu.prime(Math.floor(bitlength / 2) + 1);\n        q = await bcu.prime(Math.floor(bitlength / 2));\n        n = p * q;\n    } while (q === p || bcu.bitLength(n) !== bitlength);\n    if (simpleVariant) {\n        // If using p,q of equivalent length, a simpler variant of the key\n        // generation steps would be to set\n        // g=n+1, lambda=(p-1)(q-1), mu=lambda.invertm(n)\n        g = n + 1n;\n        lambda = (p - 1n) * (q - 1n);\n        mu = bcu.modInv(lambda, n);\n    }\n    else {\n        const n2 = n ** 2n;\n        g = getGenerator(n, n2);\n        lambda = bcu.lcm(p - 1n, q - 1n);\n        mu = bcu.modInv(L(bcu.modPow(g, lambda, n2), n), n);\n    }\n    const publicKey = new PublicKey(n, g);\n    const privateKey = new PrivateKey(lambda, mu, publicKey, p, q);\n    return { publicKey, privateKey };\n}\n/**\n * Generates a pair private, public key for the Paillier cryptosystem in synchronous mode.\n * Synchronous mode is NOT RECOMMENDED since it won't use workers and thus it'll be slower and may freeze thw window in browser's javascript.\n *\n * @param bitlength - The bit length of the public modulo\n * @param simplevariant - Use the simple variant to compute the generator (g=n+1)\n *\n * @returns A pair of public, private keys\n */\nfunction generateRandomKeysSync(bitlength = 3072, simpleVariant = false) {\n    let p, q, n, g, lambda, mu;\n    // if p and q are bitLength/2 long ->  2**(bitLength - 2) <= n < 2**(bitLength)\n    do {\n        p = bcu.primeSync(Math.floor(bitlength / 2) + 1);\n        q = bcu.primeSync(Math.floor(bitlength / 2));\n        n = p * q;\n    } while (q === p || bcu.bitLength(n) !== bitlength);\n    if (simpleVariant) {\n        // If using p,q of equivalent length, a simpler variant of the key\n        // generation steps would be to set\n        // g=n+1, lambda=(p-1)(q-1), mu=lambda.invertm(n)\n        g = n + 1n;\n        lambda = (p - 1n) * (q - 1n);\n        mu = bcu.modInv(lambda, n);\n    }\n    else {\n        const n2 = n ** 2n;\n        g = getGenerator(n, n2);\n        lambda = bcu.lcm(p - 1n, q - 1n);\n        mu = bcu.modInv(L(bcu.modPow(g, lambda, n2), n), n);\n    }\n    const publicKey = new PublicKey(n, g);\n    const privateKey = new PrivateKey(lambda, mu, publicKey, p, q);\n    return { publicKey, privateKey };\n}\nfunction getGenerator(n, n2) {\n    const alpha = bcu.randBetween(n);\n    const beta = bcu.randBetween(n);\n    return ((alpha * n + 1n) * bcu.modPow(beta, n, n2)) % n2;\n}\n\nexport { PrivateKey, PublicKey, generateRandomKeys, generateRandomKeysSync };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguYnJvd3Nlci5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3RzL1B1YmxpY0tleS50cyIsIi4uLy4uL3NyYy90cy9Qcml2YXRlS2V5LnRzIiwiLi4vLi4vc3JjL3RzL2dlbmVyYXRlUmFuZG9tS2V5cy50cyJdLCJzb3VyY2VzQ29udGVudCI6bnVsbCwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFFQTs7O01BR3FCLFNBQVM7Ozs7OztJQVc1QixZQUFhLENBQVMsRUFBRSxDQUFTO1FBQy9CLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFBO1FBQ1YsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQTtRQUN2QixJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQTtLQUNYOzs7OztJQU1ELElBQUksU0FBUztRQUNYLE9BQU8sR0FBRyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUE7S0FDN0I7Ozs7Ozs7OztJQVVELE9BQU8sQ0FBRSxDQUFTLEVBQUUsQ0FBVTtRQUM1QixJQUFJLENBQUMsS0FBSyxTQUFTLEVBQUU7WUFDbkIsR0FBRztnQkFDRCxDQUFDLEdBQUcsR0FBRyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUE7YUFDNUIsUUFBUSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFDO1NBQ3BDO1FBQ0QsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUE7S0FDdEY7Ozs7Ozs7O0lBU0QsUUFBUSxDQUFFLEdBQUcsV0FBMEI7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Q0QsQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQTtRQUNsRCxDQUFDLEdBQUcsTUFBTSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUE7UUFDOUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUE7S0FDVixRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxTQUFTLEVBQUM7SUFFbkQsSUFBSSxhQUFhLEVBQUU7Ozs7UUFJakIsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUE7UUFDVixNQUFNLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQTtRQUM1QixFQUFFLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUE7S0FDM0I7U0FBTTtRQUNMLE1BQU0sRUFBRSxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUE7UUFDbEIsQ0FBQyxHQUFHLFlBQVksQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUE7UUFDdkIsTUFBTSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUE7UUFDaEMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQTtLQUNwRDtJQUVELE1BQU0sU0FBUyxHQUFHLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQTtJQUNyQyxNQUFNLFVBQVUsR0FBRyxJQUFJLFVBQVUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUE7SUFDOUQsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsQ0FBQTtBQUNsQyxDQUFDO0FBRUQ7Ozs7Ozs7OztTQVNnQixzQkFBc0IsQ0FBRSxZQUFvQixJQUFJLEVBQUUsZ0JBQXlCLEtBQUs7SUFDOUYsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLEVBQUUsQ0FBQTs7SUFFMUIsR0FBRztRQUNELENBQUMsR0FBRyxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFBO1FBQ2hELENBQUMsR0FBRyxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUE7UUFDNUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUE7S0FDVixRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxTQUFTLEVBQUM7SUFFbkQsSUFBSSxhQUFhLEVBQUU7Ozs7UUFJakIsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUE7UUFDVixNQUFNLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQTtRQUM1QixFQUFFLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUE7S0FDM0I7U0FBTTtRQUNMLE1BQU0sRUFBRSxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUE7UUFDbEIsQ0FBQyxHQUFHLFlBQVksQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUE7UUFDdkIsTUFBTSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUE7UUFDaEMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQTtLQUNwRDtJQUVELE1BQU0sU0FBUyxHQUFHLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQTtJQUNyQyxNQUFNLFVBQVUsR0FBRyxJQUFJLFVBQVUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUE7SUFDOUQsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsQ0FBQTtBQUNsQyxDQUFDO0FBRUQsU0FBUyxZQUFZLENBQUUsQ0FBUyxFQUFFLEVBQVU7SUFDMUMsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQTtJQUNoQyxNQUFNLElBQUksR0FBRyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFBO0lBQy9CLE9BQU8sQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUE7QUFDMUQ7Ozs7In0=\n"]},"metadata":{},"sourceType":"module"}